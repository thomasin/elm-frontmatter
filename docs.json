[{"name":"Content.Decode","comment":" # Writing decoders\n\n\n\n# Declaration\n\n@docs QueryResult, frontmatter, frontmatterWithoutBody, throw, ignore\n\n\n# Attribute\n\n@docs DecodedAttribute, Attribute, attribute, renameTo\n\n\n# Basic decoders\n\n@docs Decoder, fromSyntax, string, int, float, datetime, anonymousRecord, list, reference\n\n","unions":[],"aliases":[{"name":"Attribute","comment":" A YAML field\n","args":[],"type":"Content.Decode.Internal.Attribute"},{"name":"DecodedAttribute","comment":" Decoded YAML field\n","args":[],"type":"Content.Decode.Internal.DecodedAttribute"},{"name":"Decoder","comment":" Decoders turn JSON frontmatter data into Elm types and records\n","args":["a"],"type":"Content.Decode.Internal.Decoder a"},{"name":"QueryResult","comment":" The result of trying to find a decoder for a file\n","args":[],"type":"Content.Decode.Internal.DeclarationResult"}],"values":[{"name":"anonymousRecord","comment":" Decode an anonymous record (We don't have typed records).\nYou have to create anonymous records with a list of `attribute`s.\n\n    Content.Decode.frontmatter Content.Decode.string\n        [ Content.Decode.attribute \"title\" Content.Decode.string\n        , Content.Decode.attribute \"recordtest\"\n            (Content.Decode.anonymousRecord\n                [ Content.Decode.attribute \"field1\" Content.Decode.string\n                , Content.Decode.attribute \"field2\" Content.Decode.string\n                ]\n            )\n        ]\n\n","type":"List.List Content.Decode.Attribute -> Content.Decode.Decoder (List.List Content.Decode.DecodedAttribute)"},{"name":"attribute","comment":" `attribute` is how you decode named YAML fields. They map\n1-1 to the generated Elm. The fields\nare generated in the order that they appear in the list.\n\n    {- YAML:\n    title: \"Today's newspaper\"\n    description: \"A pleasant walk\"\n\n    ---\n\n    Tea\n    -}\n\n    Content.Decode.frontmatter Content.Decode.string\n        [ Content.Decode.attribute \"title\" Content.Decode.string\n        , Content.Decode.attribute \"description\" Content.Decode.string\n        ]\n\n    {- =>\n    type alias Content =\n        { title : String\n        , description : String\n        , body : String\n        }\n\n    content : Content\n    content =\n        { title = \"Today's newspaper\"\n        , description = \"A pleasant walk\"\n        , body = \"Tea\"\n        }\n    -}\n\n","type":"String.String -> Content.Decode.Decoder a -> Content.Decode.Attribute"},{"name":"datetime","comment":" Decode Iso8601 formatted date strings. `elm/time` must be installed for the output to compile.\n\nGiven a markdown file `index.md` containing\n\n```yaml\n---\ntitle: A list of people\ntomorrow: 2016-08-04T18:53:38.297Z\n---\n\nbody text\n```\n\nAnd a decoder\n\n    Content.Decode.frontmatter Content.Decode.string\n        [ Content.Decode.attribute \"tomorrow\" Content.Decode.datetime\n        ]\n\nThis will generate the `Content/Index.elm` file\n\n    import Time\n\n    type alias Content =\n        { tomorrow : Time.Posix\n        , body : String\n        }\n\n    content : Content\n    content =\n        { tomorrow = Time.millisToPosix 1470336818297\n        , body = \"body text\"\n        }\n\n","type":"Content.Decode.Decoder Time.Posix"},{"name":"float","comment":" Decode floats\n\n    Content.Decode.frontmatter Content.Decode.frontmatter\n        [ Content.Decode.attribute \"title\" Content.Decode.string\n        , Content.Decode.attribute \"bankAccountDollars\" Content.Decode.float\n        ]\n\n","type":"Content.Decode.Decoder Basics.Float"},{"name":"fromSyntax","comment":" Create a decoder from a Syntax object.\n    This lets you use custom JSON decoders to ensure the content you are receiving is valid.\n    The Syntax object passed should be the Syntax object matching the output type of your JSON decoder.\n\n    Content.Decode.fromSyntax Content.Decode.Syntax.int\n        ( Json.Decode.int\n            |> Json.Decode.andThen (\\number ->\n                if number > 0 then\n                    Json.Decode.succeed number\n\n                else\n                    Json.Decode.fail \"Only positive numbers supported\"\n            )\n        )\n","type":"Content.Decode.Syntax.Syntax Content.Decode.Context a -> (Content.Decode.Context -> Json.Decode.Decoder a) -> Content.Decode.Decoder a"},{"name":"frontmatter","comment":" Decode a frontmatter file. This will include the file body as a `body` field in the generated record.\n    The first argument is the type that the body will be decoded as. Common options would be `Content.Decode.string` or `Content.Decode.Markdown.decode`\n\n    decoder : Content.Type.Path -> Content.Decode.QueryResult\n    decoder typePath =\n        case typePath of\n            Content.Type.Single [ \"Content\", \"Index\" ] ->\n                Content.Decode.frontmatter Content.Decode.string\n                    [ Content.Decode.attribute \"title\" Content.Decode.string\n                    , Content.Decode.attribute \"description\" Content.Decode.string\n                    ]\n\n            _ ->\n                Content.Decode.throw\n\n    {- =>\n       type alias Content =\n           { title : String\n           , description : String\n           , body : String\n           }\n\n       content : Content\n       content =\n           { title = \"Today's newspaper\"\n           , description = \"A pleasant walk\"\n           , body = \"Main content\"\n           }\n    -}\n\n","type":"Content.Decode.Decoder value -> List.List Content.Decode.Attribute -> Content.Decode.QueryResult"},{"name":"frontmatterWithoutBody","comment":" Decode a frontmatter file. This will ignore the file body.\n\n\n    decoder : Content.Type.Path -> Content.Decode.QueryResult\n    decoder typePath =\n        case typePath of\n            Content.Type.Single [ \"Content\", \"Index\" ] ->\n                Content.Decode.frontmatterWithoutBody\n                    [ Content.Decode.attribute \"title\" Content.Decode.string\n                    , Content.Decode.attribute \"description\" Content.Decode.string\n                    ]\n\n            _ ->\n                Content.Decode.throw\n\n    {- =>\n       type alias Content =\n           { title : String\n           , description : String\n           }\n\n       content : Content\n       content =\n           { title = \"Today's newspaper\"\n           , description = \"A pleasant walk\"\n           }\n    -}\n\n","type":"List.List Content.Decode.Attribute -> Content.Decode.QueryResult"},{"name":"ignore","comment":" If this is returned from the main `decoder` function it won't do anything.\nUseful when you want to allow markdown files to be created without having\na matching decoder yet.\n\n    decoder : Content.Type.Path -> Content.Decode.Declaration\n    decoder typePath =\n        case typePath of\n            Content.Type.Single [ \"Content\", \"Index\" ] ->\n                Content.Decode.frontmatterWithoutBody\n                    [ Content.Decode.attribute \"title\" Content.Decode.string\n                    , Content.Decode.attribute \"description\" Content.Decode.string\n                    ]\n\n            _ ->\n                Content.Decode.ignore\n\n","type":"Content.Decode.QueryResult"},{"name":"int","comment":" Decode ints\n\n    Content.Decode.frontmatter Content.Decode.frontmatter\n        [ Content.Decode.attribute \"title\" Content.Decode.string\n        , Content.Decode.attribute \"daysTillFullMoon\" Content.Decode.int\n        ]\n\n","type":"Content.Decode.Decoder Basics.Int"},{"name":"list","comment":" Decode a list of items. Given a markdown file `index.md` containing\n\n```yaml\n---\ntitle: A list of people\nstrings:\n    - string1\n    - string2\npeople:\n    - about/people/[person1].md\n    - about/people/[person2].md\n---\n\nbody text\n```\n\nAnd a decoder\n\n    Content.Decode.frontmatter Content.Decode.string\n        [ Content.Decode.attribute \"strings\" (Content.Decode.list Content.Decode.string)\n        , Content.Decode.attribute \"people\"\n            (Content.Decode.list (Content.Decode.reference (Content.Type.Collection [ \"Content\", \"About\", \"People\" ]))\n        ]\n\nThis will generate the `Content/Index.elm` file\n\n    type alias Content =\n        { strings : List String\n        , people : List Content.About.People.CollectionItem\n        , body : String\n        }\n\n    content : Content\n    content =\n        { strings = [ \"string1\", \"string2\" ]\n        , people = [ Content.About.People.person1, Content.About.People.person2 ]\n        , body = \"body text\"\n        }\n\n","type":"Content.Decode.Decoder a -> Content.Decode.Decoder (List.List a)"},{"name":"reference","comment":" References another content record. Given a markdown file `index.md` containing\n\n```yaml\n---\ntitle: Index\nabout: about.md\nperson1: about/people/[person1].md\n---\n\nbody text\n```\n\nAnd a decoder\n\n    Content.Decode.frontmatter Content.Decode.string\n        [ Content.Decode.attribute \"about\" (Content.Decode.reference (Content.Type.Single [ \"Content\", \"About\" ]))\n        , Content.Decode.attribute \"person1\" (Content.Decode.reference (Content.Type.Collection [ \"Content\", \"About\", \"People\" ]))\n        ]\n\nThis will generate the `Content/Index.elm` file\n\n    import Content.About.People\n\n    type alias Content =\n        { about : Content.About.Content\n        , person1 : Content.About.People.CollectionItem\n        , body : String\n        }\n\n    content : Content\n    content =\n        { about = Content.About.content\n        , person1 = Content.About.People.person1\n        , body = \"body text\"\n        }\n\n","type":"Content.Type.Path -> Content.Decode.Decoder ( Elm.Syntax.ModuleName.ModuleName, String.String )"},{"name":"renameTo","comment":" Rename an attribute! This means you can parse the same frontmatter\n    field into multiple Elm attributes.\n\n    Content.Decode.frontmatter Content.Decode.string\n        [ Content.Decode.attribute \"title\" Content.Decode.string\n        , Content.Decode.renameTo \"slug\" (Content.Decode.attribute \"title\" slugDecoder)\n        ]\n\n","type":"String.String -> Content.Decode.Attribute -> Content.Decode.Attribute"},{"name":"string","comment":" Decode strings\n\n    Content.Decode.frontmatter Content.Decode.frontmatter\n        [ Content.Decode.attribute \"title\" Content.Decode.string\n        , Content.Decode.attribute \"description\" Content.Decode.string\n        ]\n\n","type":"Content.Decode.Decoder String.String"},{"name":"throw","comment":" If this is returned from the main `decoder` function it will throw an error.\nUseful when you want to ensure that all markdown files are handled.\n\n    decoder : Content.Type.Path -> Content.Decode.QueryResult\n    decoder typePath =\n        case typePath of\n            Content.Type.Single [ \"Content\", \"Index\" ] ->\n                Content.Decode.frontmatterWithoutBody\n                    [ Content.Decode.attribute \"title\" Content.Decode.string\n                    , Content.Decode.attribute \"description\" Content.Decode.string\n                    ]\n\n            _ ->\n                Content.Decode.throw\n\n","type":"Content.Decode.QueryResult"}],"binops":[]},{"name":"Content.Decode.Image","comment":"\n\n@docs Decoder, CopyArgs, Manipulation, ActionDetails, process, batchProcess, width\n\n","unions":[],"aliases":[{"name":"ActionDetails","comment":" Image action details\n","args":[],"type":"Content.Decode.Image.Internal.ActionDetails"},{"name":"CopyArgs","comment":" Image processing configuration\n\n    imageCopyArgs : Content.Decode.Image.CopyArgs\n    imageCopyArgs =\n        { copyToDirectory = \"../static/image-gen/\"\n        , publicDirectory = \"/image-gen/\"\n        }\n\nwill copy images to the `../static/image-gen/` folder, relative to\nthe local `package.json`. Image URLs will be written with the public\ndirectory as the root i.e. `/image-gen/banner.jpg`\n\n","args":[],"type":"{ copyToDirectory : String.String, publicDirectory : String.String }"},{"name":"Decoder","comment":" An image decoder\n","args":[],"type":"Content.Decode.Decoder ( Content.Decode.Image.ActionDetails, List.List Content.Decode.Image.ActionDetails )"},{"name":"Manipulation","comment":" An image manipulation\n","args":[],"type":"Content.Decode.Image.Internal.Manipulation"}],"values":[{"name":"batchProcess","comment":" Make multiple copies of one image.\n\n\n    imageCopyArgs : Content.Decode.Image.CopyArgs\n    imageCopyArgs =\n        { copyToDirectory = \"../static/image-gen/\"\n        , publicDirectory = \"/image-gen/\"\n        }\n\n    decoder : Content.Type.Path -> Content.Decode.QueryResult\n    decoder typePath =\n        case typePath of\n            Content.Type.Collection [ \"Content\", \"About\", \"People\" ] ->\n                Content.Decode.decodeWithoutBody\n                    [ Content.Decode.attribute \"name\" Content.Decode.string\n                    , Content.Decode.attribute \"position\" Content.Decode.string\n                    , Content.Decode.attribute \"thumbnail\"\n                        (Content.Decode.Image.batchProcess imageCopyArgs\n                            ( \"300\", [ Content.Decode.Image.width 300 ] )\n                            [ ( \"600\", [ Content.Decode.Image.width 600 ] )\n                            , ( \"1200\", [ Content.Decode.Image.width 1200 ] )\n                            ]\n                        )\n                    ]\n\n            _ ->\n                Content.Decode.ignore\n\n    {-\n       type alias CollectionItem =\n           { name : String\n           , position : String\n           , thumbnail : ( ( String, String ), List ( String, String ) )\n           }\n\n       person1 : CollectionItem\n       person1 =\n           { name = \"Person 1\", position = \"Astronaut\"\n           , thumbnail =\n               ( ( \"300\", \"/image-gen/about/people/[person1]/banner-300.jpeg\" )\n               , [ ( \"600\", \"/image-gen/about/people/[person1]/banner-600.jpeg\" )\n                 , ( \"1200\", \"/image-gen/about/people/[person1]/banner-1200.jpeg\" )\n                 ]\n               )\n           }\n    -}\n\n","type":"Content.Decode.Image.CopyArgs -> ( String.String, List.List Content.Decode.Image.Manipulation ) -> List.List ( String.String, List.List Content.Decode.Image.Manipulation ) -> Content.Decode.Image.Decoder"},{"name":"process","comment":" Copy and modify an image\n\n\n    imageCopyArgs : Content.Decode.Image.CopyArgs\n    imageCopyArgs =\n        { copyToDirectory = \"../static/image-gen/\"\n        , publicDirectory = \"/image-gen/\"\n        }\n\n    decoder : Content.Type.Path -> Content.Decode.QueryResult\n    decoder typePath =\n        case typePath of\n            Content.Type.Single [ \"Content\", \"About\" ] ->\n                Content.Decode.decode\n                    [ Content.Decode.attribute \"title\" Content.Decode.string\n                    , Content.Decode.attribute \"banner\"\n                        (Content.Decode.Image.process imageCopyArgs [ Content.Decode.Image.width 1600 ])\n                    ]\n\n            _ ->\n                Content.Decode.ignore\n\n    {- =>\n       type alias Content =\n           { title : String\n           , banner : String\n           }\n\n\n       content : Content\n       content =\n           { title = \"About\"\n           , banner = \"/image-gen/banner.jpeg\"\n           }\n    -}\n\n","type":"Content.Decode.Image.CopyArgs -> List.List Content.Decode.Image.Manipulation -> Content.Decode.Image.Decoder"},{"name":"width","comment":" Resize the generated image to a specified width.\nThe image will evenly scale.\n","type":"Basics.Int -> Content.Decode.Image.Manipulation"}],"binops":[]},{"name":"Content.Decode.Markdown","comment":"\nDecode a field into a `List Markdown.Block.Block` from the [dillonkearns/elm-markdown](https://package.elm-lang.org/packages/dillonkearns/elm-markdown/latest/) package.\n\nThis lets you do some pretty cool things! To render the Markdown blocks into HTML, see [Markdown.Renderer](https://package.elm-lang.org/packages/dillonkearns/elm-markdown/latest/Markdown-Renderer)\n\n@docs decode\n","unions":[],"aliases":[],"values":[{"name":"decode","comment":"\n```elm\ndecoder : Content.Type.Path -> Content.Decode.QueryResult\ndecoder typePath =\n    case typePath of\n        Content.Type.Single [ \"Content\", \"Index\" ] ->\n            Content.Decode.frontmatter Content.Decode.Markdown.decode\n                [ Content.Decode.attribute \"title\" Content.Decode.string\n                , Content.Decode.attribute \"description\" Content.Decode.string\n                ]\n\n        _ ->\n            Content.Decode.throw\n```\n","type":"Content.Decode.Internal.Decoder (List.List Markdown.Block.Block)"}],"binops":[]},{"name":"Content.Decode.Syntax","comment":" These Syntax helpers are extensible wrappers around elm-syntax, made so you can build\ntype and function declarations in parallel.\n\n    syntax : Content.Decode.Syntax.Syntax () ( ( Int, String ), List ( String, String ) )\n    syntax =\n        Content.Decode.Syntax.tuple2\n            ( Content.Decode.Syntax.tuple2 ( Content.Decode.Syntax.int, Content.Decode.Syntax.string )\n            , Content.Decode.Syntax.list\n                (Content.Decode.Syntax.tuple2 ( Content.Decode.Syntax.string Content.Decode.Syntax.string ))\n            )\n\n@docs Syntax, noContext, string, datetime, int, float, bool, list, dict, tuple2, tuple3\n@docs node\n","unions":[],"aliases":[{"name":"Syntax","comment":" Syntax object. Fields take a `context` argument, so when you render your type\n    annotation, imports or expressions you can pass down meta. `Content.Decode.Decoder`s\n    use this to pass down the input file path so that decoders know which file they are decoding.\n","args":["context","value"],"type":"{ typeAnnotation : context -> Elm.Syntax.TypeAnnotation.TypeAnnotation, imports : context -> List.List Elm.Syntax.Import.Import, expression : context -> value -> Elm.Syntax.Expression.Expression }"}],"values":[{"name":"bool","comment":" Bool\n","type":"Content.Decode.Syntax.Syntax context Basics.Bool"},{"name":"datetime","comment":" Datetime\n","type":"Content.Decode.Syntax.Syntax context Time.Posix"},{"name":"dict","comment":" Dict\n`dict string int => Dict.Dict String Int`\n","type":"Content.Decode.Syntax.Syntax context key -> Content.Decode.Syntax.Syntax context value -> Content.Decode.Syntax.Syntax context (List.List ( key, value ))"},{"name":"float","comment":" Float\n","type":"Content.Decode.Syntax.Syntax context Basics.Float"},{"name":"int","comment":" Int\n","type":"Content.Decode.Syntax.Syntax context Basics.Int"},{"name":"list","comment":" List\n`list string => List String`\n","type":"Content.Decode.Syntax.Syntax context a -> Content.Decode.Syntax.Syntax context (List.List a)"},{"name":"noContext","comment":" A very small helper to create a Syntax object that doesn't need to use or pass on any context.\n","type":"{ typeAnnotation : Elm.Syntax.TypeAnnotation.TypeAnnotation, imports : List.List Elm.Syntax.Import.Import, expression : value -> Elm.Syntax.Expression.Expression } -> Content.Decode.Syntax.Syntax context value"},{"name":"node","comment":" Small helper for building up Elm.Syntax expressions (zero-ed out node, empty range).\n    There aren't many helpers in this module for building up custom types so I would feel bad\n    for not at least offering this.\n","type":"a -> Elm.Syntax.Node.Node a"},{"name":"string","comment":" String\n    An important note is that this will escape '\"' and '\\', as it is meant for user provided strings.\n    If you want to pass it hardcoded strings this might be a problem.\n","type":"Content.Decode.Syntax.Syntax context String.String"},{"name":"tuple2","comment":" Two element tuple\n`tuple2 ( string, int ) => ( String, Int )`\n","type":"( Content.Decode.Syntax.Syntax context a, Content.Decode.Syntax.Syntax context b ) -> Content.Decode.Syntax.Syntax context ( a, b )"},{"name":"tuple3","comment":" Three element tuple\n`tuple2 ( string, float, int ) => ( String, Float, Int )`\n","type":"( Content.Decode.Syntax.Syntax context a, Content.Decode.Syntax.Syntax context b, Content.Decode.Syntax.Syntax context c ) -> Content.Decode.Syntax.Syntax context ( a, b, c )"}],"binops":[]},{"name":"Content.Function","comment":"\n\n@docs FunctionType, Function, fromPath, PathError\n\n","unions":[{"name":"FunctionType","comment":" Generated functions can either be singleton or collection item functions.\n\n\"Singleton\" means that they don't share a type with any other function in the module.\nThese functions are made from paths with no brackets i.e `about.md`, `recipe/egg/content.md`\n\n\"Collection item\" means that they do share types with other functions.\nThese functions are made from paths with surrounding brackets i.e `recipes/[egg].md`, `recipes/[egg]/content.md`\n","args":[],"cases":[["SingletonFunction",[]],["CollectionItemFunction",[]]]},{"name":"PathError","comment":" Possible errors returned from `fromPath`\n","args":[],"cases":[["PathIsHidden",[]],["PathIsEmpty",[]],["PathIsInvalid",["String.String"]]]}],"aliases":[{"name":"Function","comment":" Function overview\n","args":[],"type":"{ moduleDir : List.List String.String, name : String.String, type_ : Content.Function.FunctionType }"}],"values":[{"name":"fromPath","comment":" Turns a file path into a possible function\n","type":"Path.Path -> Result.Result Content.Function.PathError Content.Function.Function"}],"binops":[]},{"name":"Content.Module","comment":"\nDecode a file from one or many JSON frontmatter values.\n\n@docs UndecodedModule, UndecodedFunction, Module, generate, GenerationError\n\n","unions":[{"name":"GenerationError","comment":"\nGets returnd when file generation fails\n","args":[],"cases":[["NoMatchingDecoder",["Content.Type.Path"]],["ModuleIsEmpty",[]],["InvalidOutputPath",["String.String"]],["DecoderError",["Content.Type.Path","Json.Decode.Error"]]]}],"aliases":[{"name":"Module","comment":"\nThe outputted file.\nActions are consumed by the `elm-frontmatter` npm package, and contain\ninstructions to be processed by JS code, currently limited to [image processing](Content-Decode-Image). \n","args":[],"type":"{ path : Path.Path, contents : String.String, actions : List.List { with : String.String, args : Json.Encode.Value } }"},{"name":"UndecodedFunction","comment":"\nInformation about an undecoded function. `filePath` is the path\nof the input file whose contents are decoded to form the function body.\n`functionType` is whether this function's type is a singleton or collection item.\nSingleton function types are named `Content`, whereas collection item types are named `CollectionItem`.\nThis gets converted to a [Content.Type.Path](Content-Type#Path) and used to query for the decoder.\n\n```elm\n{ filePath = \"ingredients/egg.md\", functionType = Content.Function.SingletonFunction, ... } == Content.Type.Single [ \"Content\", \"Ingredients\", \"Egg\" ]\n\n{ filePath = \"[recipes].md\", functionType = Content.Function.CollectionItemFunction, ... } == Content.Type.Collection [ \"Content\", \"Recipes\" ]\n```\n\n`fileFrontmatter` contains the JSON encoded frontmatter value of the file. This function expects data\nto be in the same shape as [gray-matter](https://github.com/jonschlinkert/gray-matter) output.\n\n```json\n{\n    \"content\": \"A string containing the file body\",\n    \"data\": {\n        \"title\": \"An object containing file attributes\",\n        \"date\": \"2016-08-04T18:53:38.297Z\"\n    }\n}\n```\n","args":[],"type":"{ inputFilePath : Path.Path, type_ : Content.Function.FunctionType, frontmatter : Json.Decode.Value }"},{"name":"UndecodedModule","comment":"\nThe outline of a yet-to-be-decoded module.\n","args":[],"type":"{ dir : List.List String.String, functions : Dict.Dict String.String Content.Module.UndecodedFunction }"}],"values":[{"name":"generate","comment":"\nTakes a function that can query for a decoder based on type path, and an undecoded module.\nReturns the file path and contents for the decoded module.\n","type":"Path.Platform -> (Content.Type.Path -> Content.Decode.QueryResult) -> Content.Module.UndecodedModule -> Result.Result Content.Module.GenerationError Content.Module.Module"}],"binops":[]},{"name":"Content.Type","comment":"\n\n# Content.Type\n\nThis is passed in to the main `decoder` function in `Content.elm`, and can be matched\nagainst to assign decoders based on module directory and either single or collection item type.\n\n@docs Path, toString, toTypeName, toModuleDir\n\n","unions":[{"name":"Path","comment":"\nA type path, e.g. `Single [ \"Content\", \"About\" ]` or `Collection [ \"Content\", \"People\" ]`\nThe List String is the module that the type is contained in.  \n`Single` indicates this type/decoder only applies to one function/input frontmatter file.\n`Collection` indicates that type/decoder type will apply to multiple functions/input frontmatter files.\n","args":[],"cases":[["Single",["List.List String.String"]],["Collection",["List.List String.String"]]]}],"aliases":[],"values":[{"name":"toModuleDir","comment":"\n```\nContent.Type.toModuleDir (Content.Type.Single [ \"Recipes\", \"Egg\" ]) == [ \"Recipes\", \"Egg\" ]\nContent.Type.toModuleDir (Content.Type.Collection [ \"Recipes\", \"Ingredients\" ]) == [ \"Recipes\", \"Ingredients\" ]\n```\n","type":"Content.Type.Path -> List.List String.String"},{"name":"toString","comment":"\n```\nContent.Type.toString (Content.Type.Single [ \"Recipes\", \"Egg\" ]) == \"Recipes.Egg.Content\"\nContent.Type.toString (Content.Type.Collection [ \"Recipes\", \"Ingredients\" ]) == \"Recipes.Ingredients.CollectionItem\"\n```\n","type":"Content.Type.Path -> String.String"},{"name":"toTypeName","comment":"\n```\nContent.Type.toTypeName (Content.Type.Single [ \"Recipes\", \"Egg\" ]) == \"Content\"\nContent.Type.toTypeName (Content.Type.Collection [ \"Recipes\", \"Ingredients\" ]) == \"CollectionItem\"\n```\n","type":"Content.Type.Path -> String.String"}],"binops":[]}]